---
layout: post
title: Weakly and strongly typed values in .NET
tags: [C#, .NET, types, optimizations, benchmarks, JIT, assembly, hash codes]
permalink: /weakly-and-strongly-typed-values-in-dotnet
excerpt_separator: <!--more-->
---

Recently I read [an interesting article](https://blog.codingmilitia.com/2024/04/13/primitive-vs-strongly-typed-dictionary-keys-feat-frozen-collections-and-benchmarkdotnet) by [JoÃ£o Antunes](https://antunes.dev) covering how different type of .NET collections handle strongly and weakly typed keys, but it lacks a very important part, an analysis of why some results are almost identical in some cases and not in others. So, let's dive in and find answers to these questions.

<!--more-->

# Preparations

The setup is the same as JoÃ£o used in his work ([the source](https://github.com/joaofbantunes/LooseBenchmarks/tree/main/src/PrimitiveVsStronglyTypedKeyLookup)) except a few things:
Â * AMD Ryzen 7 4700U instead of Apple M1 silicone,
Â * addition of the `[DisassemblyDiagnoser]` attribute to get the assembly code generated by the runtime,
Â * and a change of the target framework to `net9.0` because with `net8.0` it crashes on my machine with `SIGSEGV`.

```csharp
[RankColumn]
[MemoryDiagnoser]
[DisassemblyDiagnoser]
[GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByParams, BenchmarkLogicalGroupRule.ByCategory)]
public class Benchmark
{
Â Â // ...
}

public class BaseImplementation<T> where T : notnull
{
Â Â private readonly T _toLookup;
Â Â private readonly StronglyTypedKey<T> _toLookupStronglyTyped;
Â 
Â Â private readonly Dictionary<T, string> _traditional;
Â Â private readonly Dictionary<StronglyTypedKey<T>, string> _traditionalWithStronglyTypedKey;
Â Â private readonly Dictionary<StronglyTypedKey<T>, string> _traditionalWithStronglyTypedKeyWithCustomComparer;

Â Â private readonly FrozenDictionary<T, string> _frozen;
Â Â private readonly FrozenDictionary<StronglyTypedKey<T>, string> _frozenWithStronglyTypedKey;
Â Â private readonly FrozenDictionary<StronglyTypedKey<T>, string> _frozenWithStronglyTypedKeyWithCustomComparer;

Â Â public BaseImplementation(int n, IEqualityComparer<StronglyTypedKey<T>> equalityComparer, Func<int, T> factory)
Â Â {
Â Â Â Â var contents = Enumerable.Range(0, n).Select(factory).ToArray();

Â Â Â Â _toLookup = contents.Last();
Â Â Â Â _toLookupStronglyTyped = new StronglyTypedKey<T>(_toLookup);

Â Â Â Â _traditional = contents.ToDictionary(x => x, x => x.ToString()!);
Â Â Â Â _traditionalWithStronglyTypedKey = contents.ToDictionary(x => new StronglyTypedKey<T>(x), x => x.ToString()!);
Â Â Â Â _traditionalWithStronglyTypedKeyWithCustomComparer = contents.ToDictionary(x => new StronglyTypedKey<T>(x), x => x.ToString()!, equalityComparer);

Â Â Â Â _frozen = _traditional.ToFrozenDictionary();
Â Â Â Â _frozenWithStronglyTypedKey = _traditionalWithStronglyTypedKey.ToFrozenDictionary();
Â Â Â Â _frozenWithStronglyTypedKeyWithCustomComparer = _traditionalWithStronglyTypedKey.ToFrozenDictionary(equalityComparer);
Â Â }

Â Â public string LookupTraditional() =>
Â Â Â Â _traditional[_toLookup];

Â Â public string LookupTraditionalWithStronglyTypedKey() =>
Â Â Â Â _traditionalWithStronglyTypedKey[_toLookupStronglyTyped];

Â Â public string LookupTraditionalWithStronglyTypedKeyWithCustomComparer() =>
Â Â Â Â _traditionalWithStronglyTypedKeyWithCustomComparer[_toLookupStronglyTyped];

Â Â public string LookupFrozen() =>
Â Â Â Â _frozen[_toLookup];

Â Â public string LookupFrozenWithStronglyTypedKey() =>
Â Â Â Â _frozenWithStronglyTypedKey[_toLookupStronglyTyped];

Â Â public string LookupFrozenWithStronglyTypedKeyWithCustomComparer() =>
Â Â Â Â _frozenWithStronglyTypedKeyWithCustomComparer[_toLookupStronglyTyped];
}
```

# Numbers time!

Actually, there are so many numbers that showing all of them is pointless and hell as boring. Therefore, let's limit the area of discussion by excluding the frozen dictionary and focusing on traditional lookups using `Dictionary<TKey, TValue>`.

Still, there are lots of numbers that can be found in the original blog post, I won't repeat them here and will just mention that there are two cases. In the first one the benchmarks for `T` and `StroglyTypedKey<T>` give us very close results, and with a custom comparer it's a bit slower. It happens for `int` and `Guid`. If `float` is used too the picture will be the same. And in the second case, for `string`, lookups over `T` are faster than over `StroglyTypedKey<T>`, and even with a custom comparer over `StroglyTypedKey<T>` are better than without it. The difference between these two cases is the kind of `T` being used, a value type or a reference type.

## Generic keys over a value type

The original article used `int` and `Guid`, and the picture is the same for both. Therefore, we will continue only with one of these types, with `int`. 

| MethodÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â                    Â | NÂ    Â | Mean   Â Â | ErrorÂ    Â | StdDevÂ   Â | Code Size |
|--------------------------------------------------- |------ |---------:|----------:|----------:|----------:|
| LookupTraditionalIntÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â   Â Â           Â Â | 1Â    Â |Â 4.742 ns | 0.0091 ns | 0.0085 ns |   Â Â 445 B |
| LookupTraditionalWithStronglyTypedKeyIntÂ Â Â Â Â Â Â   Â Â | 1Â    Â |Â 4.308 ns | 0.0069 ns | 0.0062 ns |   Â Â 438 B |
|Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â                       Â | Â Â    Â |Â Â Â Â Â      |      Â Â Â Â Â |Â Â Â       Â Â |   Â    Â Â Â Â |
| LookupTraditionalIntÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â             Â | 10Â   Â |Â 4.231 ns | 0.0050 ns | 0.0047 ns |   Â Â 445 B |
| LookupTraditionalWithStronglyTypedKeyIntÂ Â Â Â Â Â Â Â   Â | 10Â   Â |Â 4.436 ns | 0.0058 ns | 0.0054 ns |   Â Â 438 B |
|Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â           Â Â             Â |Â Â     Â |Â      Â Â Â Â |Â       Â Â Â Â |Â Â       Â Â Â |   Â    Â Â Â Â |
| LookupTraditionalIntÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â             Â | 100  Â |Â 4.858 ns | 0.0062 ns | 0.0058 ns |   Â Â 436 B |
| LookupTraditionalWithStronglyTypedKeyIntÂ Â Â Â Â Â Â Â   Â | 100  Â |Â 4.251 ns | 0.0122 ns | 0.0114 ns |   Â Â 447 B |
|Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â           Â Â             Â |Â Â     Â |Â      Â Â Â Â |Â Â       Â Â Â |Â Â       Â Â Â |      Â Â Â Â Â |
| LookupTraditionalIntÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â             Â Â | 1000 Â |Â 4.951 ns | 0.0314 ns | 0.0294 ns |   Â Â 436 B |
| LookupTraditionalWithStronglyTypedKeyIntÂ Â Â Â Â Â Â Â   Â | 1000 Â |Â 4.317 ns | 0.0440 ns | 0.0411 ns |   Â Â 447 B |
|Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â           Â Â             Â |Â Â     Â |     Â Â Â Â Â |Â Â       Â Â Â |Â       Â Â Â Â |   Â Â Â    Â Â |
| LookupTraditionalIntÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â             Â | 10000 |Â 4.749 ns | 0.0495 ns | 0.0439 ns |   Â Â 436 B |
| LookupTraditionalWithStronglyTypedKeyIntÂ Â Â Â Â Â Â Â   Â | 10000 |Â 4.378 ns | 0.0031 ns | 0.0027 ns |   Â Â 438 B |

So, why there's almost no difference? Well, the earlier addition of `[DisassemblyDiagnoser]` was made to answer that question by comparing the assembly code generated by the runtime.

```diff
-; Benchmark.LookupTraditionalInt()
+; Benchmark.LookupTraditionalWithStronglyTypedKeyInt()
Â Â Â Â pushÂ Â Â rbp
Â Â Â Â pushÂ Â Â rbx
Â Â Â Â pushÂ Â Â rax
Â Â Â Â leaÂ Â Â rbp,[rsp+10]
Â Â Â Â movÂ Â Â rdi,[rdi+10]
-Â Â Â movÂ Â Â rsi,[rdi+8]
-Â Â Â movÂ Â Â ebx,[rdi+38]
+Â Â Â movÂ Â Â rsi,[rdi+10]
+Â Â Â movÂ Â Â ebx,[rdi+3C]
Â Â Â Â cmpÂ Â Â [rsi],sil
Â Â Â Â movÂ Â Â rdi,rsi
Â Â Â Â movÂ Â Â esi,ebx
-Â Â Â callÂ Â Â qword ptr [7E75ED89F540]; System.Collections.Generic.Dictionary`2[[System.Int32, System.Private.CoreLib],[System.__Canon, System.Private.CoreLib]].FindValue(Int32)
+Â Â Â callÂ Â Â qword ptr [70E3098942E8]; System.Collections.Generic.Dictionary`2[[StronglyTypedKey`1[[System.Int32, System.Private.CoreLib]], PrimitiveVsStronglyTypedKeyLookup],[System.__Canon, System.Private.CoreLib]].FindValue(StronglyTypedKey`1<Int32>)
Â Â Â Â testÂ Â Â rax,rax
Â Â Â Â jeÂ Â Â Â short M00_L00
Â Â Â Â movÂ Â Â rax,[rax]
Â Â Â Â addÂ Â Â rsp,8
Â Â Â Â popÂ Â Â rbx
Â Â Â Â popÂ Â Â rbp
Â Â Â Â ret
Â M00_L00:
Â Â Â Â movÂ Â Â edi,ebx
-Â Â Â callÂ Â Â qword ptr [7E75ED9C6790]
+Â Â Â callÂ Â Â qword ptr [70E30996FE28]
Â Â Â Â intÂ Â Â 3
Â ; Total bytes of code 57
```

The only difference we can see between these snipped is only the target method names. Nothing interesting to see here.

```diff
-; System.Collections.Generic.Dictionary`2[[System.Int32, System.Private.CoreLib],[System.__Canon, System.Private.CoreLib]].FindValue(Int32)
+; System.Collections.Generic.Dictionary`2[[StronglyTypedKey`1[[System.Int32, System.Private.CoreLib]], PrimitiveVsStronglyTypedKeyLookup],[System.__Canon, System.Private.CoreLib]].FindValue(StronglyTypedKey`1<Int32>)
Â Â Â Â pushÂ Â Â rbp
Â Â Â Â pushÂ Â Â r15
Â Â Â Â pushÂ Â Â r14
Â Â Â Â pushÂ Â Â r13
Â Â Â Â pushÂ Â Â r12
Â Â Â Â pushÂ Â Â rbx
Â Â Â Â subÂ Â Â rsp,18
Â Â Â Â leaÂ Â Â rbp,[rsp+40]
Â Â Â Â movÂ Â Â rbx,rdi
Â Â Â Â movÂ Â Â r15d,esi
Â Â Â Â movÂ Â Â rdi,[rbx+8]
Â Â Â Â testÂ Â Â rdi,rdi
-Â Â Â jeÂ Â Â Â near ptr M01_L06
+Â Â Â jeÂ Â Â Â near ptr M01_L03
Â Â Â Â movÂ Â Â r14,[rbx+18]
Â Â Â Â testÂ Â Â r14,r14
-Â Â Â jneÂ Â Â near ptr M01_L03
+Â Â Â jneÂ Â Â near ptr M01_L04
Â Â Â Â movÂ Â Â eax,r15d
Â Â Â Â movÂ Â Â esi,eax
Â Â Â Â imulÂ Â Â rsi,[rbx+30]
Â Â Â Â shrÂ Â Â rsi,20
Â Â Â Â incÂ Â Â rsi
Â Â Â Â movÂ Â Â r11d,[rdi+8]
Â Â Â Â movÂ Â Â ecx,r11d
Â Â Â Â imulÂ Â Â rsi,rcx
Â Â Â Â shrÂ Â Â rsi,20
Â Â Â Â cmpÂ Â Â esi,r11d
Â Â Â Â jaeÂ Â Â near ptr M01_L11
Â Â Â Â movÂ Â Â esi,esi
Â Â Â Â movÂ Â Â r13d,[rdi+rsi*4+10]
Â Â Â Â movÂ Â Â r12,[rbx+10]
Â Â Â Â xorÂ Â Â ecx,ecx
Â Â Â Â decÂ Â Â r13d
Â Â Â Â movÂ Â Â edx,[r12+8]
Â M01_L00:
Â Â Â Â cmpÂ Â Â edx,r13d
-Â Â Â jbeÂ Â Â near ptr M01_L06
+Â Â Â jbeÂ Â Â short M01_L03
Â Â Â Â movÂ Â Â edi,r13d
Â Â Â Â leaÂ Â Â rdi,[rdi+rdi*2]
Â Â Â Â leaÂ Â Â r13,[r12+rdi*8+10]
Â Â Â Â cmpÂ Â Â [r13+8],r15d
-Â Â Â jneÂ Â Â near ptr M01_L07
-Â Â Â cmpÂ Â Â [r13+10],eax
-Â Â Â jneÂ Â Â near ptr M01_L07
+Â Â Â jneÂ Â Â near ptr M01_L08
+Â Â Â movÂ Â Â edi,[r13+10]
+Â Â Â cmpÂ Â Â edi,eax
+Â Â Â jneÂ Â Â near ptr M01_L08
Â M01_L01:
Â Â Â Â cmpÂ Â Â [r13],r13b
Â Â Â Â movÂ Â Â rax,r13
Â M01_L02:
Â Â Â Â addÂ Â Â rsp,18
Â Â Â Â popÂ Â Â rbx
Â Â Â Â popÂ Â Â r12
Â Â Â Â popÂ Â Â r13
Â Â Â Â popÂ Â Â r14
Â Â Â Â popÂ Â Â r15
Â Â Â Â popÂ Â Â rbp
Â Â Â Â ret
Â M01_L03:
+Â Â Â xorÂ Â Â eax,eax
+Â Â Â jmpÂ Â Â short M01_L02
+M01_L04:
Â Â Â Â movÂ Â Â rdi,r14
Â Â Â Â movÂ Â Â esi,r15d
-Â Â Â movÂ Â Â r11,7E75EBE70720
+Â Â Â movÂ Â Â r11,70E307E40730
Â Â Â Â callÂ Â Â qword ptr [r11]
Â Â Â Â movÂ Â Â r12d,eax
Â Â Â Â movÂ Â Â rax,[rbx+8]
Â Â Â Â movÂ Â Â esi,r12d
Â Â Â Â imulÂ Â Â rsi,[rbx+30]
Â Â Â Â shrÂ Â Â rsi,20
Â Â Â Â incÂ Â Â rsi
Â Â Â Â movÂ Â Â edi,[rax+8]
Â Â Â Â movÂ Â Â edx,edi
Â Â Â Â imulÂ Â Â rsi,rdx
Â Â Â Â shrÂ Â Â rsi,20
Â Â Â Â cmpÂ Â Â esi,edi
Â Â Â Â jaeÂ Â Â near ptr M01_L11
Â Â Â Â movÂ Â Â esi,esi
-Â Â Â movÂ Â Â esi,[rax+rsi*4+10]
+Â Â Â movÂ Â Â eax,[rax+rsi*4+10]
Â Â Â Â movÂ Â Â rbx,[rbx+10]
Â Â Â Â xorÂ Â Â r13d,r13d
-Â Â Â decÂ Â Â esi
-M01_L04:
+Â Â Â decÂ Â Â eax
+M01_L05:
Â Â Â Â movÂ Â Â ecx,[rbx+8]
-Â Â Â cmpÂ Â Â ecx,esi
-Â Â Â jbeÂ Â Â short M01_L06
-Â Â Â movÂ Â Â esi,esi
-Â Â Â leaÂ Â Â rax,[rsi+rsi*2]
+Â Â Â cmpÂ Â Â ecx,eax
+Â Â Â jbeÂ Â Â short M01_L03
+Â Â Â movÂ Â Â eax,eax
+Â Â Â leaÂ Â Â rax,[rax+rax*2]
Â Â Â Â leaÂ Â Â rax,[rbx+rax*8+10]
Â Â Â Â cmpÂ Â Â [rax+8],r12d
-Â Â Â jeÂ Â Â Â short M01_L08
-M01_L05:
-Â Â Â movÂ Â Â esi,[rax+0C]
+Â Â Â jeÂ Â Â Â short M01_L09
+M01_L06:
+Â Â Â movÂ Â Â eax,[rax+0C]
Â Â Â Â incÂ Â Â r13d
Â Â Â Â cmpÂ Â Â ecx,r13d
-Â Â Â jbÂ Â Â Â short M01_L10
-Â Â Â jmpÂ Â Â short M01_L04
-M01_L06:
-Â Â Â xorÂ Â Â eax,eax
-Â Â Â jmpÂ Â Â near ptr M01_L02
+Â Â Â jaeÂ Â Â short M01_L05
Â M01_L07:
+Â Â Â callÂ Â Â qword ptr [70E308F85278]
+Â Â Â intÂ Â Â 3
+M01_L08:
Â Â Â Â movÂ Â Â r13d,[r13+0C]
Â Â Â Â incÂ Â Â ecx
Â Â Â Â cmpÂ Â Â edx,ecx
Â Â Â Â jaeÂ Â Â near ptr M01_L00
-Â Â Â jmpÂ Â Â short M01_L10
-M01_L08:
+Â Â Â jmpÂ Â Â short M01_L07
+M01_L09:
Â Â Â Â movÂ Â Â [rbp-2C],ecx
Â Â Â Â movÂ Â Â [rbp-38],rax
Â Â Â Â movÂ Â Â esi,[rax+10]
Â Â Â Â movÂ Â Â rdi,r14
Â Â Â Â movÂ Â Â edx,r15d
-Â Â Â movÂ Â Â r11,7E75EBE70728
+Â Â Â movÂ Â Â r11,70E307E40738
Â Â Â Â callÂ Â Â qword ptr [r11]
Â Â Â Â testÂ Â Â eax,eax
-Â Â Â jneÂ Â Â short M01_L09
+Â Â Â jneÂ Â Â short M01_L10
Â Â Â Â movÂ Â Â eax,r13d
Â Â Â Â movÂ Â Â ecx,[rbp-2C]
Â Â Â Â movÂ Â Â r13,[rbp-38]
Â Â Â Â movÂ Â Â edx,eax
Â Â Â Â movÂ Â Â rax,r13
Â Â Â Â movÂ Â Â r13d,edx
-Â Â Â jmpÂ Â Â short M01_L05
-M01_L09:
+Â Â Â jmpÂ Â Â short M01_L06
+M01_L10:
Â Â Â Â movÂ Â Â r13,[rbp-38]
Â Â Â Â jmpÂ Â Â near ptr M01_L01
-M01_L10:
-Â Â Â callÂ Â Â qword ptr [7E75ECFB5278]
-Â Â Â intÂ Â Â 3
Â M01_L11:
Â Â Â Â callÂ Â Â CORINFO_HELP_RNGCHKFAIL
Â Â Â Â intÂ Â Â 3
-; Total bytes of code 388
+; Total bytes of code 381
```

Now there is more diversity one might say, but even here the outputs are almost identical except for a few minor things:
* used registers
* memory addresses of some methods
* location of the `M01_L07`/`M01_L10` branch which seems to be `ThrowInvalidOperationException_ConcurrentOperationsNotSupported`.

The source code of `FindValue` is identical for both cases and it looks like:

```csharp
internal ref TValue FindValue(TKey key)
{
Â Â ref Entry entry = ref Unsafe.NullRef<Entry>();
Â Â if (_buckets != null)
Â Â {
Â Â Â Â Debug.Assert(_entries != null, "expected entries to be != null");
Â Â Â Â IEqualityComparer<TKey>? comparer = _comparer;
Â Â Â Â if (typeof(TKey).IsValueType && // comparer can only be null for value types; enable JIT to eliminate entire if block for ref types
Â Â Â Â Â Â comparer == null)
Â Â Â Â {
Â Â Â Â Â Â uint hashCode = (uint)key.GetHashCode();
Â Â Â Â Â Â int i = GetBucket(hashCode);
Â Â Â Â Â Â Entry[]? entries = _entries;
Â Â Â Â Â Â uint collisionCount = 0;

Â Â Â Â Â Â // ValueType: Devirtualize with EqualityComparer<TKey>.Default intrinsic
Â Â Â Â Â Â i--; // Value in _buckets is 1-based; subtract 1 from i. We do it here so it fuses with the following conditional.
Â Â Â Â Â Â do
Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â // Test in if to drop range check for following array access
Â Â Â Â Â Â Â Â if ((uint)i >= (uint)entries.Length)
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â goto ReturnNotFound;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â entry = ref entries[i];
Â Â Â Â Â Â Â Â if (entry.hashCode == hashCode && EqualityComparer<TKey>.Default.Equals(entry.key, key))
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â goto ReturnFound;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â i = entry.next;

Â Â Â Â Â Â Â Â collisionCount++;
Â Â Â Â Â Â } while (collisionCount <= (uint)entries.Length);
Â Â Â Â }
Â Â Â Â else
Â Â Â Â {
Â Â Â Â Â Â // ...
Â Â Â Â }
Â Â }

Â Â goto ReturnNotFound;

ReturnFound:
Â Â ref TValue value = ref entry.value;
Return:
Â Â return ref value;
ReturnNotFound:
Â Â value = ref Unsafe.NullRef<TValue>();
Â Â goto Return;
}
```

The runtime generates a separate method implementation for each generic type if at least one of its generic parameters is a value type, our current case, `TKey` is a value type for `int` and `StronglyTypedKey<int>`. Since there's a non-shared implementation the runtime attempts to apply another technique named "devirtualization". It replaces virtual calls with direct invocations if it's exactly determined. In some cases, it even inlines the body of the callee, and that's happened for `EqualityComparer<TKey>.Default.Equals`.

Now it's clear why there's no difference for the observed case without a custom comparer. There is simply no indirect call inside of the lookup method. And when there is a virtual call to `GetHashCode` at the beginning of the lookup, and then for each matching bucket the comparer's `Equals` method is also virtually invoked. It takes some additional time and makes the code a bit slower.

## Generic keys over a reference type

After discussing about shared and non-shared generics, and devirtualization no wonder that in the table below we see a different picture for the `string` benchmarks. All we know is that the `string` type is by-reference even if it has the by-value semantics. The JIT compiler generates an universal implementation for `Dictionary<StronglyTypedKey<string>, string>` that can be used for any `Dictionary<StronglyTypedKey<T>, TValue>` where `T` and `TValue` are references.

| MethodÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â                             Â Â | NÂ Â    | MeanÂ Â    Â | ErrorÂ Â    | StdDevÂ Â   | Code Size |
|-------------------------------------------------------------- |------ |----------:|----------:|----------:|----------:|
| LookupTraditionalStringÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â                     | 1Â    Â | 19.302 ns | 0.0387 ns | 0.0362 ns |   Â Â 401 B |
| LookupTraditionalWithStronglyTypedKeyStringÂ Â Â Â Â Â Â Â Â           | 1Â    Â | 38.275 ns | 0.0404 ns | 0.0378 ns |   Â Â 792 B |
| LookupTraditionalWithStronglyTypedKeyStringWithCustomComparer | 1   Â Â | 31.926 ns | 0.0499 ns | 0.0467 ns |   Â Â 614 B |
|Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â                                 |Â Â     Â |Â Â       Â Â Â |Â       Â Â Â Â |      Â Â Â Â Â |      Â Â Â Â Â |
| LookupTraditionalStringÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â                     | 10Â   Â | 16.565 ns | 0.0393 ns | 0.0368 ns |   Â Â 401 B |
| LookupTraditionalWithStronglyTypedKeyStringÂ Â Â Â Â Â Â Â Â           | 10Â   Â | 37.746 ns | 0.0299 ns | 0.0280 ns |   Â Â 792 B |
| LookupTraditionalWithStronglyTypedKeyStringWithCustomComparer | 10Â   Â | 32.230 ns | 0.3138 ns | 0.2935 ns |   Â Â 614 B |
|Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â                                 |Â   Â   Â |      Â Â Â Â Â |Â Â Â       Â Â |      Â Â Â Â  |      Â Â Â Â Â |
| LookupTraditionalStringÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â                     | 100  Â | 17.792 ns | 0.0362 ns | 0.0339 ns |   Â Â 410 B |
| LookupTraditionalWithStronglyTypedKeyStringÂ Â Â Â Â Â Â Â Â           | 100  Â | 38.961 ns | 0.0492 ns | 0.0460 ns |   Â Â 792 B |
| LookupTraditionalWithStronglyTypedKeyStringWithCustomComparer | 100  Â | 31.624 ns | 0.1461 ns | 0.1220 ns |   Â Â 614 B |
|Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â                                 |Â Â     Â |      Â Â Â Â Â |Â       Â Â Â Â |Â       Â Â Â Â |   Â    Â Â Â Â |
| LookupTraditionalStringÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â                     | 1000 Â | 20.657 ns | 0.1705 ns | 0.1511 ns |   Â Â 410 B |
| LookupTraditionalWithStronglyTypedKeyStringÂ Â Â Â Â Â Â Â           Â | 1000 Â | 40.340 ns | 0.0433 ns | 0.0405 ns |   Â Â 792 B |
| LookupTraditionalWithStronglyTypedKeyStringWithCustomComparer | 1000 Â | 32.797 ns | 0.1520 ns | 0.1422 ns |   Â Â 614 B |
|Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â                                 Â |Â Â     Â |Â       Â Â Â Â |Â       Â Â Â Â |Â Â       Â Â Â |   Â Â    Â Â Â |
| LookupTraditionalStringÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â                     Â Â Â | 10000 | 18.818 ns | 0.0832 ns | 0.0778 ns |   Â Â 410 B |
| LookupTraditionalWithStronglyTypedKeyStringÂ Â Â Â           Â Â Â Â Â | 10000 | 39.701 ns | 0.0759 ns | 0.0710 ns |   Â Â 792 B |
| LookupTraditionalWithStronglyTypedKeyStringWithCustomComparer | 10000 | 32.882 ns | 0.0286 ns | 0.0253 ns |   Â Â 620 B |

In any produced assembly a shared generic type can be spotted by usage of the `__Canon` type instead of the actual generic parameters. That's exactly what we have for the strongly typed generic keys when `T` is `string`:

```nasm
; Benchmark.LookupTraditionalWithStronglyTypedKeyString()
Â Â Â Â pushÂ Â Â rbp
Â Â Â Â pushÂ Â Â rbx
Â Â Â Â pushÂ Â Â rax
Â Â Â Â leaÂ Â Â rbp,[rsp+10]
Â Â Â Â movÂ Â Â rdi,[rdi+8]
Â Â Â Â movÂ Â Â rsi,[rdi+18]
Â Â Â Â movÂ Â Â rbx,[rdi+28]
Â Â Â Â cmpÂ Â Â [rsi],sil
Â Â Â Â movÂ Â Â rdi,rsi
Â Â Â Â movÂ Â Â rsi,rbx
Â Â Â Â callÂ Â Â qword ptr [76939B3677C8]; System.Collections.Generic.Dictionary`2[[StronglyTypedKey`1[[System.__Canon, System.Private.CoreLib]], PrimitiveVsStronglyTypedKeyLookup],[System.__Canon, System.Private.CoreLib]].FindValue(StronglyTypedKey`1<System.__Canon>)
Â Â Â Â testÂ Â Â rax,rax
Â Â Â Â jeÂ Â Â Â short M00_L00
Â Â Â Â movÂ Â Â rax,[rax]
Â Â Â Â addÂ Â Â rsp,8
Â Â Â Â popÂ Â Â rbx
Â Â Â Â popÂ Â Â rbp
Â Â Â Â ret
M00_L00:
Â Â Â Â movÂ Â Â rsi,rbx
Â Â Â Â movÂ Â Â rdi,offset MD_System.ThrowHelper.ThrowKeyNotFoundException[[StronglyTypedKey`1[[System.String, System.Private.CoreLib]], PrimitiveVsStronglyTypedKeyLookup]](StronglyTypedKey`1<System.String>)
Â Â Â Â callÂ Â Â qword ptr [76939B46FBA0]
Â Â Â Â intÂ Â Â 3
; Total bytes of code 70
```

Expectedly a shared code might be slower than a non-shared one, but there's a good reason for having sharing in general. Since any reference type is a pointer under the hood to the corresponding object on the heap, most of the code is the same. No need to waste storage and RAM on duplicating pieces when they can be collapsed into a single block. If there's a type dependant branching it's always possible to obtain the type handle from the object or a special register for generic methods. Still, it doesn't answer why a custom comparer boosts the execution.

## Comparision magic

To understand why the usage of a custom comparer outperforms the case when it's not provided, the `Dictionary<TKey, TValue>`'s code should be checked.

```csharp
public Dictionary(int capacity, IEqualityComparer<TKey>? comparer)
{
Â Â if (capacity < 0)
Â Â {
Â Â Â Â ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.capacity);
Â Â }

Â Â if (capacity > 0)
Â Â {
Â Â Â Â Initialize(capacity);
Â Â }

Â Â // For reference types, we always want to store a comparer instance, either
Â Â // the one provided, or if one wasn't provided, the default (accessing
Â Â // EqualityComparer<TKey>.Default with shared generics on every dictionary
Â Â // access can add measurable overhead).Â For value types, if no comparer is
Â Â // provided, or if the default is provided, we'd prefer to use
Â Â // EqualityComparer<TKey>.Default.Equals on every use, enabling the JIT to
Â Â // devirtualize and possibly inline the operation.
Â Â if (!typeof(TKey).IsValueType)
Â Â {
Â Â Â Â _comparer = comparer ?? EqualityComparer<TKey>.Default;

Â Â Â Â // Special-case EqualityComparer<string>.Default, StringComparer.Ordinal, and StringComparer.OrdinalIgnoreCase.
Â Â Â Â // We use a non-randomized comparer for improved perf, falling back to a randomized comparer if the
Â Â Â Â // hash buckets become unbalanced.
Â Â Â Â if (typeof(TKey) == typeof(string) &&
Â Â Â Â Â Â NonRandomizedStringEqualityComparer.GetStringComparer(_comparer!) is IEqualityComparer<string> stringComparer)
Â Â Â Â {
Â Â Â Â Â Â _comparer = (IEqualityComparer<TKey>)stringComparer;
Â Â Â Â }
Â Â }
Â Â else if (comparer is not null && // first check for null to avoid forcing default comparer instantiation unnecessarily
Â Â Â Â Â Â Â comparer != EqualityComparer<TKey>.Default)
Â Â {
Â Â Â Â _comparer = comparer;
Â Â }
}
```

Our wrapper is a value type, so the last `if` block applies. And indeed, the `_comparer` is set only when provided to the constructor and if it's not the default one in case of a value type. Therefore, we have no comparer assigned, but something shall be used instead, right? That's exactly what we have seen, `EqualityComparer<TKey>.Default.Equals`:

```csharp
internal ref TValue FindValue(TKey key)
{
Â Â // ...

Â Â ref Entry entry = ref Unsafe.NullRef<Entry>();
Â Â if (_buckets != null)
Â Â {
Â Â Â Â Debug.Assert(_entries != null, "expected entries to be != null");
Â Â Â Â IEqualityComparer<TKey>? comparer = _comparer;
Â Â Â Â if (typeof(TKey).IsValueType && // comparer can only be null for value types; enable JIT to eliminate entire if block for ref types
Â Â Â Â Â Â comparer == null)
Â Â Â Â {
Â Â Â Â Â Â // ..
Â Â Â Â Â Â do
Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â // ..
Â Â Â Â Â Â Â Â // Resolution of the default equality comparer ðŸ‘‡
Â Â Â Â Â Â Â Â if (entry.hashCode == hashCode && EqualityComparer<TKey>.Default.Equals(entry.key, key))
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â goto ReturnFound;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â // ..
Â Â Â Â Â Â } while (collisionCount <= (uint)entries.Length);
Â Â Â Â }
Â Â Â Â else
Â Â Â Â {
Â Â Â Â Â Â Debug.Assert(comparer is not null);
Â Â Â Â Â Â // ..
Â Â Â Â Â Â do
Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â // ..
Â Â Â Â Â Â Â Â // Just a virtual call, nothing else ðŸ‘‡
Â Â Â Â Â Â Â Â if (entry.hashCode == hashCode && comparer.Equals(entry.key, key))
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â goto ReturnFound;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â // ..
Â Â Â Â Â Â } while (collisionCount <= (uint)entries.Length);
Â Â Â Â }
Â Â // ..
}
```

Yeah, babe, the default key comparer is resolved each time when there's a matching hash code even if it's a collision. It's done that way for a very good reason we already discussed, devirtualization. The JIT compiler can only spot a possible optimization site by the full match, i.e. exactly `EqualityComparer<T>.Default.Equals`. Otherwise, if the comparer is stored in a variable in the same method and used later, the optimization cannot be applied. It even works in our current case:

```nasm
; System.Collections.Generic.Dictionary`2[[StronglyTypedKey`1[[System.__Canon, System.Private.CoreLib]], PrimitiveVsStronglyTypedKeyLookup],[System.__Canon, System.Private.CoreLib]].FindValue(StronglyTypedKey`1<System.__Canon>)
Â Â Â Â ; ...
M01_L02:
Â Â Â Â movÂ Â Â rdi,rsi
Â Â Â Â callÂ Â Â qword ptr [76939B36CD08]; System.Collections.Generic.EqualityComparer`1[[StronglyTypedKey`1[[System.__Canon, System.Private.CoreLib]], PrimitiveVsStronglyTypedKeyLookup]].get_Default()
Â Â Â Â movÂ Â Â rdi,rax
Â Â Â Â movÂ Â Â rcx,[r14+10]
Â Â Â Â movÂ Â Â rax,offset MT_System.Collections.Generic.GenericEqualityComparer`1[[StronglyTypedKey`1[[System.String, System.Private.CoreLib]], PrimitiveVsStronglyTypedKeyLookup]]
Â Â Â Â cmpÂ Â Â [rdi],rax
Â Â Â Â jneÂ Â Â near ptr M01_L17
Â Â Â Â ; Inlined body of "StronglyTypedKey<T>.Equals" which contains inlined "string.Equals"
Â Â Â Â movÂ Â Â rsi,[rbp-38]
Â Â Â Â testÂ Â Â rcx,rcx
Â Â Â Â jeÂ Â Â Â near ptr M01_L16
Â Â Â Â testÂ Â Â rsi,rsi
Â Â Â Â jeÂ Â Â Â near ptr M01_L15
Â Â Â Â cmpÂ Â Â rcx,rsi
Â Â Â Â jneÂ Â Â near ptr M01_L14
Â Â Â Â movÂ Â Â r8d,1
M01_L03:
Â Â Â Â testÂ Â Â r8d,r8d
Â Â Â Â jeÂ Â Â Â short M01_L12
Â Â Â Â ; ...
M01_L14:
Â Â Â Â movÂ Â Â edx,[rcx+8]
Â Â Â Â cmpÂ Â Â edx,[rsi+8]
Â Â Â Â jneÂ Â Â short M01_L13
Â Â Â Â leaÂ Â Â rdi,[rcx+0C]
Â Â Â Â addÂ Â Â rsi,0C
Â Â Â Â movÂ Â Â edx,[rcx+8]
Â Â Â Â addÂ Â Â edx,edx
Â Â Â Â callÂ Â Â qword ptr [76939A724B58]; System.SpanHelpers.SequenceEqual(Byte ByRef, Byte ByRef, UIntPtr)
Â Â Â Â movÂ Â Â r8d,eax
Â Â Â Â jmpÂ Â Â near ptr M01_L03
Â Â Â Â ; ...
```

It fetches the default comparer first and then checks if it's a cached instance of `GenericEqualityComparer<StronglyTypedKey<string>>`. If so, then it uses the devirtualized equality method of `StronglyTypedKey<string>` which in turn is a simple string equality inlined too.

The problem here is that for shared generics the default comparer has to be retrieved each time and it isn't cheap. Perhaps, if there would be a method similar to `RuntimeHelpers.IsReferenceOrContainsReferences<T>`, but which would tell us if `T` is a shared generic or not, the dictionary's constructor can be changed in such a way that for shared generics it will set the comparer like for reference types.

## It's not over yet!

Do you think that the troubles came to an end? No, there's one more reason for the strongly typed key over `string` benchmark to be slow. Earlier I showed you the dictionary's constructor which has a specially crafted logic when the key is a type of `string`.

```csharp
public Dictionary(int capacity, IEqualityComparer<TKey>? comparer)
{
Â Â // ..

Â Â if (!typeof(TKey).IsValueType)
Â Â {
Â Â Â Â _comparer = comparer ?? EqualityComparer<TKey>.Default;

Â Â Â Â // Special-case EqualityComparer<string>.Default, StringComparer.Ordinal, and StringComparer.OrdinalIgnoreCase.
Â Â Â Â // We use a non-randomized comparer for improved perf, falling back to a randomized comparer if the
Â Â Â Â // hash buckets become unbalanced.
Â Â Â Â if (typeof(TKey) == typeof(string) &&
Â Â Â Â Â Â NonRandomizedStringEqualityComparer.GetStringComparer(_comparer!) is IEqualityComparer<string> stringComparer)
Â Â Â Â {
Â Â Â Â Â Â _comparer = (IEqualityComparer<TKey>)stringComparer;
Â Â Â Â }

Â Â Â Â //..
Â Â }
}
```

And here it is, `NonRandomizedStringEqualityComparer`. a special equality comparer which instead of `GetHashCode` invocations on a string calls `GetNonRandomizedHashCode`. Yeah, I know, it feels very suspicious. While one might expect that `GetHashCode` on a string produces a stable value only depending on its content, it's not the case. It also uses a different algorithm, Marvin hash, and a random seed generated only once every time the application runs. The whole point of that thing is the prevention of hash flooding attacks, and since it's about huge amounts of data the protection doesn't apply for small collections when collision probabilities are low and equality operations aren't expensive, i.e. till the collection reaches some threshold. After that, the .NET switches to a randomized equality comparer and rehashes all entries in the collection.

```csharp
private bool TryInsert(TKey key, TValue value, InsertionBehavior behavior)
{
Â Â // ...
Â Â // Value types never rehash
Â Â if (!typeof(TKey).IsValueType && collisionCount > HashHelpers.HashCollisionThreshold && comparer is NonRandomizedStringEqualityComparer)
Â Â {
Â Â Â Â // If we hit the collision threshold we'll need to switch to the comparer which uses randomized string hashing
Â Â Â Â // i.e. EqualityComparer<string>.Default.
Â Â Â Â Resize(entries.Length, true);
Â Â }
Â Â // ...
}

private void Resize(int newSize, bool forceNewHashCodes)
{
Â Â // Value types never rehash
Â Â Debug.Assert(!forceNewHashCodes || !typeof(TKey).IsValueType);
Â Â Debug.Assert(_entries != null, "_entries should be non-null");
Â Â Debug.Assert(newSize >= _entries.Length);

Â Â Entry[] entries = new Entry[newSize];

Â Â int count = _count;
Â Â Array.Copy(_entries, entries, count);

Â Â if (!typeof(TKey).IsValueType && forceNewHashCodes)
Â Â {
Â Â Â Â Debug.Assert(_comparer is NonRandomizedStringEqualityComparer);
Â Â Â Â IEqualityComparer<TKey> comparer = _comparer = (IEqualityComparer<TKey>)((NonRandomizedStringEqualityComparer)_comparer).GetRandomizedEqualityComparer();

Â Â Â Â for (int i = 0; i < count; i++)
Â Â Â Â {
Â Â Â Â Â Â if (entries[i].next >= -1)
Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â entries[i].hashCode = (uint)comparer.GetHashCode(entries[i].key);
Â Â Â Â Â Â }
Â Â Â Â }
Â Â }
Â Â // ..
}
``` 

# A positive note

Hopefully, you won't use `StrongTypedKey<T>` in your code and will create a new wrapper for each specific case, so the compiler will protect you from messing up with unrelated values. Really, `StronglyTypeKey<T>` adds nothing to `T` except hiding its operators and methods, you still can assign aÂ `StronglyTypeKey<T>` instance to a logically unrelated local or a wrong parameter. What you should do is write down a completely new type for each case like, let's say, a serial number:

```csharp
public readonly record struct SerialNumber(string Value);
```

Now you cannot accidentally use it for anything else than a serial number, but how is it compared to `string` in performance? A simple benchmark for rescue:

```csharp
private Dictionary<SerialNumber, string> _serialNumbers = null!;
private SerialNumber _serialNumberToLookup;

private Dictionary<string, string> _strings = null!;
private string _stringToLookup = null!;

[GlobalSetup]
public void Setup()
{
Â Â var data = Enumerable.Range(0, N).Select(x => x.ToString());

Â Â _serialNumbers = data.ToDictionary(x => new SerialNumber(x));
Â Â _serialNumberToLookup = _serialNumbers.Last().Key;

Â Â _strings = data.ToDictionary(x => x);
Â Â _stringToLookup = _strings.Last().Key;
}

[Params(1, 10, 100, 1_000, 10_000)]
public int N { get; set; }

[Benchmark]
public string LookupSerialNumber() =>
Â Â _serialNumbers[_serialNumberToLookup];

[Benchmark]
public string LookupString() =>
Â Â _strings[_stringToLookup];
```

| MethodÂ Â Â        Â Â Â | NÂ    Â | MeanÂ Â    Â | ErrorÂ    Â | StdDevÂ   Â | Code Size |
|------------------- |------ |----------:|----------:|----------:|----------:|
| LookupSerialNumber | 1Â    Â |Â  7.001 ns | 0.0127 ns | 0.0119 ns |Â    Â 576 B |
| LookupStringÂ Â Â     | 1Â    Â | 11.311 ns | 0.1537 ns | 0.1437 ns |Â    Â 406 B |
| LookupSerialNumber | 10Â   Â |Â  6.943 ns | 0.0154 ns | 0.0128 ns |Â    Â 576 B |
| LookupStringÂ Â Â     | 10Â   Â | 10.798 ns | 0.0971 ns | 0.0811 ns |Â    Â 406 B |
| LookupSerialNumber | 100Â   |Â  7.610 ns | 0.0100 ns | 0.0093 ns |Â    Â 576 B |
| LookupStringÂ Â     Â | 100Â   | 11.104 ns | 0.2189 ns | 0.1941 ns |Â    Â 406 B |
| LookupSerialNumber | 1000Â  |Â  7.791 ns | 0.0771 ns | 0.0721 ns |Â    Â 576 B |
| LookupStringÂ Â Â     | 1000Â  | 11.834 ns | 0.0832 ns | 0.0695 ns |Â    Â 397 B |
| LookupSerialNumber | 10000 |Â  9.538 ns | 0.0773 ns | 0.0686 ns |Â    Â 576 B |
| LookupStringÂ     Â Â | 10000 | 11.463 ns | 0.0966 ns | 0.0856 ns |Â    Â 406 B |

As expected, usage of `SerialNumber` as a key is slower than with `string`, but the difference is hardly noticeable. If you still need the same performance as for raw strings then you could implement a non-randomized hash algorithm that provides the best result for your case, and deal with the consequences, but in my opinion, it isn't worth it.

# Outro

Hope you enjoyed the reading and learned something new about type safety, generics, optimizations, and making representative benchmarks. For further reading on the touched topics here's a list of recommendations:
* [CoreCLR Design: Guarded Devirtualization](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/jit/GuardedDevirtualization.md)
* [Book of the Runtime: Shared Generics Design](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/shared-generics.md)
* [Why is string.GetHashCode() different each time I run my program in .NET Core?](https://andrewlock.net/why-is-string-gethashcode-different-each-time-i-run-my-program-in-net-core/)
